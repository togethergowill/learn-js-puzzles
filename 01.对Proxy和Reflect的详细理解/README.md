# learn-js-puzzles
这是一个学习js过程中，遇到困难疑惑总结的仓库


# 1. 对Proxy的详细总结
## 1.1 数据监听的方式
1）在E6之前，数据监听主要使用Object.defineProperty()方法来实现，但是这种方法实现数据监听，存在很多的缺点。
* 第一：该方法设计的初衷就不是用于监听对象的属性的。随着技术的发展需要，强行让它变为数据属性描述符。
* 第二：该方法由于设计初衷的原因，是没有提供更多丰富可用的对象属性操作，如新增属性，删除属性等
* 第三：该方法需要通过for遍历循环，实现对属性的监听，也就是该方法不能够对对象之间做监听
  
2）在ES5之后，通过Proxy的方式对对象进行监听，在Proxy出现后，解决了上述的所有痛点
* Proxy 通过代理的思想，在对对象进行操作的时候可以直接操作Proxy对象，而不去操作原对象。
* 通过Proxy的方式，操作Proxy对象即可，Proxy代理的对象被访问或者被修改，在Proxy中可以做更多的操作，比如数据截持（让某个属性变为不可修改的属性等）、改变原对象中get/set函数的this指向（需配合Reflect使用）等
  
## 1.2 vue2和vue3响应式的原理
在vue响应式原理，主要是通过监听对象数据的变化，只要是数据发生变化，就会调用render中的h函数（已被收集的依赖函数）。

# 2. Reflect的使用
1）Proxy已经可以满足对象的监听，为什么还需要引入Reflect类？
* E6之前基本所有对对象操作的方法都挂载在了Object类上面，Object本身就是构造函数。从代码逻辑来说，把对对象的方法都挂载到一个构造函数上，是不合适的。
* Reflect的出现就是把所有对对象操作的方法，挂载到Reflect函数上。
  
# 3. Reflect和Proxy的结合使用的优点
1）因为Reflect函数，是有返回值的，结合Proxy的set/get，加上if判断语句，就能够知道对对象的操作是否成功。
2）因为Reflect有返回值，所以能够通过这个返回值来抛出异常，消除静默错误
3）Reflect的receiver参数，可以改变对象set/get的this指向。具体用于场景现阶段还没遇到
